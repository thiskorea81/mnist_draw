<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>MNIST 손글씨 수집 도구 (반응형 + 지우개)</title>

  <!-- Vue 3 CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- JSZip & FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
    }
    #app {
      max-width: 1000px;
      margin: 0 auto;
      background: #fff;
      padding: 16px 20px 24px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    }
    h1 {
      margin-top: 0;
      font-size: 20px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }
    .digit-buttons {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }
    .digit-btn, .tool-btn {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fafafa;
      cursor: pointer;
      font-size: 14px;
    }
    .digit-btn.active,
    .tool-btn.active {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    button.action {
      padding: 8px 12px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #10b981;
      color: #fff;
      font-size: 14px;
    }
    button.action.secondary {
      background: #6b7280;
    }
    button.action.danger {
      background: #ef4444;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .canvas-wrapper {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
    }
    canvas {
      border: 1px solid #ddd;
      background: #fff;
      /* 내부 해상도는 고정(600x300), 화면에 보이는 크기는 반응형 */
      width: 100%;
      max-width: 900px;
      height: auto;
      aspect-ratio: 2 / 1;
      image-rendering: pixelated;
      border-radius: 8px;

      /* 태블릿에서 스크롤/줌 제스처를 막고 그리기 인식 */
      touch-action: none;
    }
    .hint {
      font-size: 13px;
      color: #6b7280;
    }
    .samples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .sample-block {
      margin-top: 16px;
    }
    .samples img {
      width: 56px; /* 28x28 두 배 정도 */
      height: 56px;
      border: 1px solid #ddd;
      border-radius: 4px;
      image-rendering: pixelated;
      background: #fff;
    }
    .status {
      margin-top: 8px;
      font-size: 13px;
      color: #374151;
    }
  </style>
</head>
<body>
<div id="app">
  <h1>MNIST 스타일 손글씨 수집 (반응형 Canvas + 지우개)</h1>

  <div class="toolbar">
    <div><strong>현재 숫자:</strong></div>
    <div class="digit-buttons">
      <button
        v-for="d in 10"
        :key="d"
        class="digit-btn"
        :class="{ active: currentDigit === d-1 }"
        @click="setDigit(d-1)"
      >
        {{ d-1 }}
      </button>
    </div>

    <div style="display:flex; gap:4px; align-items:center;">
      <span style="font-size:13px; color:#374151;">도구:</span>
      <button
        class="tool-btn"
        :class="{ active: toolMode === 'pen' }"
        @click="setTool('pen')"
      >
        펜
      </button>
      <button
        class="tool-btn"
        :class="{ active: toolMode === 'eraser' }"
        @click="setTool('eraser')"
      >
        지우개
      </button>
    </div>

    <button class="action secondary" @click="clearCanvas">전체 지우기</button>

    <button class="action" @click="sliceTo28x28">
      50칸 → 28×28 원본 50장 저장
    </button>

    <button
      class="action"
      :disabled="originalsCount < 50 || isWorking"
      @click="generateAndDownload"
    >
      (원본+변환) 1000장 생성 & ZIP 다운로드
    </button>

    <button class="action danger" @click="resetDigitData">
      현재 숫자 데이터 초기화
    </button>
  </div>

  <div class="status">
    선택 숫자: <strong>{{ currentDigit }}</strong> /
    저장된 원본(28×28): <strong>{{ originalsCount }}</strong> 장
    <span v-if="isWorking"> &nbsp;⏳ 이미지 생성/압축 중...</span>
  </div>

  <div class="canvas-wrapper">
    <canvas id="drawCanvas"></canvas>
    <div class="hint">
      - 내부 해상도는 600×300이며, 10×5칸(총 50칸)으로 나뉩니다. 칸 크기는 화면 크기에 맞게 비율로 조절됩니다.<br>
      - <b>펜/지우개</b> 버튼으로 도구를 바꿀 수 있고, 지우개는 흰색 굵은 선으로 부분 삭제합니다.<br>
      - 각 칸에 같은 숫자를 50번 쓰고, <b>“50칸 → 28×28 원본 50장 저장”</b> 버튼을 누르면<br>
        28×28 이미지가 50장 메모리에 저장됩니다(가장자리 1픽셀 테두리는 흰색으로 처리).<br>
      - <b>“1000장 생성 & ZIP 다운로드”</b> 버튼을 누르면 원본 + 증강 합계 1000장을 ZIP으로 받고,<br>
        아래에 <b>기하 변환 5개 + 노이즈 중심 5개</b> 샘플이 표시됩니다.
    </div>
  </div>

  <div class="sample-block" v-if="originalSamples.length">
    <h3>원본 28×28 샘플 (최대 10개)</h3>
    <div class="samples">
      <img v-for="(src, idx) in originalSamples" :key="idx" :src="src" />
    </div>
  </div>

  <div class="sample-block" v-if="hasAugmentedSamples">
    <h3>증강 샘플 (총 10개: 기하 변환 5개 + 노이즈 5개)</h3>

    <div v-if="augmentedSamples.geo.length">
      <h4 style="margin:4px 0 2px;">기하 변환 (회전/이동/크기)</h4>
      <div class="samples">
        <div v-for="(s, idx) in augmentedSamples.geo" :key="'g'+idx" style="text-align:center;">
          <img :src="s.url" />
          <div style="font-size:11px; margin-top:4px; color:#444;">
            Rotate: {{ s.info.rotate }}<br>
            Shift: {{ s.info.shift }}<br>
            Scale: {{ s.info.scale }}<br>
            Noise: {{ s.info.noise }}
          </div>
        </div>
      </div>
    </div>

    <div v-if="augmentedSamples.noise.length">
      <h4 style="margin:4px 0 2px;">노이즈 중심 (위치·크기 고정)</h4>
      <div class="samples">
        <div v-for="(s, idx) in augmentedSamples.noise" :key="'n'+idx" style="text-align:center;">
          <img :src="s.url" />
          <div style="font-size:11px; margin-top:4px; color:#444;">
            Rotate: {{ s.info.rotate }}<br>
            Shift: {{ s.info.shift }}<br>
            Scale: {{ s.info.scale }}<br>
            Noise: {{ s.info.noise }}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const { createApp, ref, computed, onMounted } = Vue;

  const COLS = 10;
  const ROWS = 5;

  // 숫자별 28x28 원본 저장소
  const digitStore = {};
  for (let d = 0; d <= 9; d++) {
    digitStore[d] = { originals: [] };
  }

  function applyAugmentation(baseCanvas, preset = null) {
    const w = 28, h = 28;
    const aug = document.createElement('canvas');
    aug.width = w;
    aug.height = h;
    const ctx = aug.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);

    const angleDeg = preset && typeof preset.angleDeg === 'number'
      ? preset.angleDeg
      : (Math.random() - 0.5) * 40;
    const angle = angleDeg * (Math.PI / 180);

    const scale = preset && typeof preset.scale === 'number'
      ? preset.scale
      : 0.9 + Math.random() * 0.2;

    const dx = preset && typeof preset.dx === 'number'
      ? preset.dx
      : (Math.random() - 0.5) * 6;

    const dy = preset && typeof preset.dy === 'number'
      ? preset.dy
      : (Math.random() - 0.5) * 6;

    const useNoise = preset && typeof preset.useNoise === 'boolean'
      ? preset.useNoise
      : Math.random() < 0.7;

    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle);
    ctx.scale(scale, scale);
    ctx.translate(dx, dy);
    ctx.drawImage(baseCanvas, -w / 2, -h / 2, w, h);
    ctx.restore();

    if (useNoise) {
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 30;
        data[i]   = Math.max(0, Math.min(255, data[i]   + noise));
        data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
        data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
      }
      ctx.putImageData(imgData, 0, 0);
    }

    return {
      canvas: aug,
      info: {
        rotate: angleDeg.toFixed(1) + "°",
        shift: `(${dx.toFixed(1)}, ${dy.toFixed(1)})`,
        scale: scale.toFixed(2),
        noise: useNoise ? "ON" : "OFF"
      }
    };
  }

  function augment28x28(baseCanvas) {
    return applyAugmentation(baseCanvas, null);
  }

  createApp({
    setup() {
      const currentDigit = ref(0);
      const originalsCount = ref(0);
      const originalSamples = ref([]);

      const augmentedSamples = ref({ geo: [], noise: [] });
      const hasAugmentedSamples = computed(
        () => augmentedSamples.value.geo.length > 0 ||
              augmentedSamples.value.noise.length > 0
      );

      const isWorking = ref(false);
      const toolMode = ref('pen'); // 'pen' or 'eraser'

      let canvas, ctx;
      let drawing = false;
      let lastX = 0, lastY = 0;

      function setDigit(d) {
        currentDigit.value = d;
        originalsCount.value = digitStore[d].originals.length;
        originalSamples.value = digitStore[d].originals
          .slice(0, 10)
          .map(c => c.toDataURL("image/jpeg", 0.9));
        augmentedSamples.value = { geo: [], noise: [] };
      }

      function setTool(mode) {
        toolMode.value = mode;
      }

      function initCanvas() {
        canvas.width = 600;   // 내부 논리 해상도
        canvas.height = 300;

        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
      }

      function drawGrid() {
        const cellW = canvas.width / COLS;
        const cellH = canvas.height / ROWS;

        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;

        for (let c = 1; c < COLS; c++) {
          const x = c * cellW;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let r = 1; r < ROWS; r++) {
          const y = r * cellH;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }
      }

      function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        return { x, y };
      }

      function pointerDown(e) {
        e.preventDefault();
        drawing = true;
        const { x, y } = getCanvasPos(e);
        lastX = x;
        lastY = y;
      }

      function pointerMove(e) {
        if (!drawing) return;
        e.preventDefault();
        const { x, y } = getCanvasPos(e);

        if (toolMode.value === 'pen') {
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 4;
        } else { // eraser
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 12; // 지우개는 좀 더 굵게
        }

        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastX = x;
        lastY = y;
      }

      function pointerUp(e) {
        e && e.preventDefault();
        drawing = false;
      }

      function attachEvents() {
        const opts = { passive: false };

        canvas.addEventListener("pointerdown", pointerDown, opts);
        canvas.addEventListener("pointermove", pointerMove, opts);
        canvas.addEventListener("pointerup", pointerUp, opts);
        canvas.addEventListener("pointerleave", pointerUp, opts);
        window.addEventListener("pointerup", pointerUp, opts);

        // touch 이벤트 보조 (일부 브라우저 대비)
        canvas.addEventListener("touchstart", (e) => {
          pointerDown(e.touches[0]);
          e.preventDefault();
        }, opts);
        canvas.addEventListener("touchmove", (e) => {
          pointerMove(e.touches[0]);
          e.preventDefault();
        }, opts);
        canvas.addEventListener("touchend", (e) => {
          pointerUp(e.changedTouches[0]);
          e.preventDefault();
        }, opts);
      }

      function clearCanvas() {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
      }

      function sliceTo28x28() {
        const temp = document.createElement("canvas");
        temp.width = 28;
        temp.height = 28;
        const tctx = temp.getContext("2d");

        const store = digitStore[currentDigit.value];
        store.originals = [];
        originalSamples.value = [];
        augmentedSamples.value = { geo: [], noise: [] };

        const cellW = canvas.width / COLS;
        const cellH = canvas.height / ROWS;

        const totalCells = COLS * ROWS;
        for (let i = 0; i < totalCells; i++) {
          const col = i % COLS;
          const row = Math.floor(i / COLS);
          const sx = col * cellW;
          const sy = row * cellH;

          tctx.fillStyle = "#ffffff";
          tctx.fillRect(0, 0, 28, 28);
          tctx.drawImage(canvas, sx, sy, cellW, cellH, 0, 0, 28, 28);

          // 가장자리 1픽셀 테두리 흰색으로 덮어서 그리드 선 제거
          tctx.fillStyle = "#ffffff";
          tctx.fillRect(0, 0, 28, 1);
          tctx.fillRect(0, 27, 28, 1);
          tctx.fillRect(0, 0, 1, 28);
          tctx.fillRect(27, 0, 1, 28);

          const clone = document.createElement("canvas");
          clone.width = 28;
          clone.height = 28;
          clone.getContext("2d").drawImage(temp, 0, 0);
          store.originals.push(clone);

          if (i < 10) {
            originalSamples.value.push(
              clone.toDataURL("image/jpeg", 0.9)
            );
          }
        }

        originalsCount.value = store.originals.length;
        alert(`숫자 ${currentDigit.value}의 28×28 원본 ${store.originals.length}장을 메모리에 저장했습니다.`);
      }

      function resetDigitData() {
        if (!confirm(`숫자 ${currentDigit.value}의 저장된 이미지를 모두 지울까요?`)) return;
        digitStore[currentDigit.value].originals = [];
        originalsCount.value = 0;
        originalSamples.value = [];
        augmentedSamples.value = { geo: [], noise: [] };
      }

      async function generateAndDownload() {
        const digit = currentDigit.value;
        const store = digitStore[digit];
        const originals = store.originals;

        if (!originals || originals.length < 1) {
          alert("먼저 50칸을 채우고 '50칸 → 28×28 원본 50장 저장'을 눌러주세요.");
          return;
        }

        isWorking.value = true;
        augmentedSamples.value = { geo: [], noise: [] };

        const TOTAL = 1000;
        const needAug = Math.max(0, TOTAL - originals.length);

        const zip = new JSZip();
        const folder = zip.folder(`digit_${digit}`);

        // 원본 저장
        originals.forEach((c, idx) => {
          const fileIndex = idx + 1;
          const filename = `img_${digit}_${String(fileIndex).padStart(3, "0")}.jpg`;
          const dataUrl = c.toDataURL("image/jpeg", 0.9);
          const base64 = dataUrl.split(",")[1];
          folder.file(filename, base64, { base64: true });
        });

        const geoSamples = [];
        const noiseSamples = [];

        // 증강 생성
        for (let i = 0; i < needAug; i++) {
          const base = originals[Math.floor(Math.random() * originals.length)];

          let preset = null;
          let sampleCategory = null;

          if (geoSamples.length < 5) {
            preset = {
              angleDeg: (Math.random() - 0.5) * 40,
              dx: (Math.random() - 0.5) * 6,
              dy: (Math.random() - 0.5) * 6,
              scale: 0.9 + Math.random() * 0.2,
              useNoise: false
            };
            sampleCategory = "geo";
          } else if (noiseSamples.length < 5) {
            preset = {
              angleDeg: 0,
              dx: 0,
              dy: 0,
              scale: 1.0,
              useNoise: true
            };
            sampleCategory = "noise";
          } else {
            preset = null;
            sampleCategory = null;
          }

          const { canvas: augCanvas, info } = applyAugmentation(base, preset);
          const fileIndex = originals.length + i + 1;
          const filename = `img_${digit}_${String(fileIndex).padStart(3, "0")}.jpg`;
          const dataUrl = augCanvas.toDataURL("image/jpeg", 0.9);
          const base64 = dataUrl.split(",")[1];
          folder.file(filename, base64, { base64: true });

          if (sampleCategory === "geo" && geoSamples.length < 5) {
            geoSamples.push({ url: dataUrl, info });
          } else if (sampleCategory === "noise" && noiseSamples.length < 5) {
            noiseSamples.push({ url: dataUrl, info });
          }
        }

        augmentedSamples.value = { geo: geoSamples, noise: noiseSamples };

        const blob = await zip.generateAsync({ type: "blob" });
        saveAs(blob, `digit_${digit}_1000_images.zip`);
        isWorking.value = false;
        alert(`숫자 ${digit}에 대해 원본 + 증강 합계 1000장을 ZIP으로 저장했습니다.`);
      }

      onMounted(() => {
        canvas = document.getElementById("drawCanvas");
        ctx = canvas.getContext("2d");
        initCanvas();
        attachEvents();
      });

      return {
        currentDigit,
        originalsCount,
        originalSamples,
        augmentedSamples,
        hasAugmentedSamples,
        isWorking,
        toolMode,
        setDigit,
        setTool,
        clearCanvas,
        sliceTo28x28,
        generateAndDownload,
        resetDigitData
      };
    }
  }).mount("#app");
</script>
</body>
</html>
