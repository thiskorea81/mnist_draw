<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>MNIST 손글씨 수집 도구</title>

  <!-- Vue 3 CDN -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- JSZip & FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #f5f5f5;
    }
    #app {
      max-width: 1200px;
      margin: 0 auto;
      background: #fff;
      padding: 16px 20px 24px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
    }
    h1 {
      margin-top: 0;
      font-size: 20px;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }
    .digit-buttons {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }
    .digit-btn {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fafafa;
      cursor: pointer;
      font-size: 14px;
    }
    .digit-btn.active {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    button.action {
      padding: 8px 12px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #10b981;
      color: #fff;
      font-size: 14px;
    }
    button.action.secondary {
      background: #6b7280;
    }
    button.action.danger {
      background: #ef4444;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .canvas-wrapper {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
    canvas {
      border: 1px solid #ddd;
      background: #fff;
      /* 내부는 300x150이지만 크게 보이게 확대 */
      width: 1200px;
      height: 600px;
      image-rendering: pixelated;
      border-radius: 8px;
      
      touch-action: none;
    }
    .hint {
      font-size: 13px;
      color: #6b7280;
    }
    .samples {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .sample-block {
      margin-top: 16px;
    }
    .samples img {
      width: 56px; /* 28x28 두 배 정도 */
      height: 56px;
      border: 1px solid #ddd;
      border-radius: 4px;
      image-rendering: pixelated;
      background: #fff;
    }
    .status {
      margin-top: 8px;
      font-size: 13px;
      color: #374151;
    }
  </style>
</head>
<body>
<div id="app">
  <h1>MNIST 스타일 손글씨 수집 (Vue + Canvas)</h1>

  <div class="toolbar">
    <div><strong>현재 숫자:</strong></div>
    <div class="digit-buttons">
      <button
        v-for="d in 10"
        :key="d"
        class="digit-btn"
        :class="{ active: currentDigit === d-1 }"
        @click="setDigit(d-1)"
      >
        {{ d-1 }}
      </button>
    </div>

    <button class="action secondary" @click="clearCanvas">전체 지우기</button>

    <button class="action" @click="sliceTo28x28">
      50칸 → 28×28 원본 50장 저장
    </button>

    <button
      class="action"
      :disabled="originalsCount < 50 || isWorking"
      @click="generateAndDownload"
    >
      (원본+변환) 1000장 생성 & ZIP 다운로드
    </button>

    <button class="action danger" @click="resetDigitData">
      현재 숫자 데이터 초기화
    </button>
  </div>

  <div class="status">
    선택 숫자: <strong>{{ currentDigit }}</strong> /
    저장된 원본(28×28): <strong>{{ originalsCount }}</strong> 장
    <span v-if="isWorking"> &nbsp;⏳ 이미지 생성/압축 중...</span>
  </div>

  <div class="canvas-wrapper">
    <canvas id="drawCanvas" width="300" height="150"></canvas>
    <div class="hint">
      - 화면에는 크게 보이지만 내부 해상도는 300×150 (10×5칸, 한 칸 30×30)<br>
      - 각 칸에 같은 숫자를 손으로 50번 쓰고, <b>“50칸 → 28×28 원본 50장 저장”</b> 버튼을 누르면
        <code>img_숫자_001.jpg ~ img_숫자_050.jpg</code>의 원본 데이터가 메모리에 저장됩니다.<br>
      - 이때 각 28×28 이미지의 **가장자리 1픽셀 테두리는 흰색으로 처리**해서 그리드 선이 제거됩니다.<br>
      - <b>“1000장 생성 & ZIP 다운로드”</b> 버튼을 누르면 원본 포함 1000장(증강 이미지 포함)을 ZIP으로 내려받고,<br>
        아래에 <b>기하 변환 5개 + 노이즈 중심 5개</b> 샘플이 표시됩니다.
    </div>
  </div>

  <div class="sample-block" v-if="originalSamples.length">
    <h3>원본 28×28 샘플 (최대 10개)</h3>
    <div class="samples">
      <img v-for="(src, idx) in originalSamples" :key="idx" :src="src" />
    </div>
  </div>

  <div class="sample-block" v-if="hasAugmentedSamples">
    <h3>증강 샘플 (총 10개: 기하 변환 5개 + 노이즈 5개)</h3>

    <div v-if="augmentedSamples.geo.length">
      <h4 style="margin:4px 0 2px;">기하 변환 (회전/이동/크기)</h4>
      <div class="samples">
        <div v-for="(s, idx) in augmentedSamples.geo" :key="'g'+idx" style="text-align:center;">
          <img :src="s.url" />
          <div style="font-size:11px; margin-top:4px; color:#444;">
            Rotate: {{ s.info.rotate }}<br>
            Shift: {{ s.info.shift }}<br>
            Scale: {{ s.info.scale }}<br>
            Noise: {{ s.info.noise }}
          </div>
        </div>
      </div>
    </div>

    <div v-if="augmentedSamples.noise.length">
      <h4 style="margin:4px 0 2px;">노이즈 중심 (위치·크기 고정)</h4>
      <div class="samples">
        <div v-for="(s, idx) in augmentedSamples.noise" :key="'n'+idx" style="text-align:center;">
          <img :src="s.url" />
          <div style="font-size:11px; margin-top:4px; color:#444;">
            Rotate: {{ s.info.rotate }}<br>
            Shift: {{ s.info.shift }}<br>
            Scale: {{ s.info.scale }}<br>
            Noise: {{ s.info.noise }}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const { createApp, ref, computed, onMounted } = Vue;

  // 숫자별로 28x28 원본 캔버스를 저장
  const digitStore = {};
  for (let d = 0; d <= 9; d++) {
    digitStore[d] = {
      originals: []  // 28x28 offscreen canvas 배열
    };
  }

  /**
   * 28x28 이미지에 증강을 적용하는 공통 함수
   * preset이 없으면 랜덤 증강, 있으면 지정된 파라미터로 증강
   */
  function applyAugmentation(baseCanvas, preset = null) {
    const w = 28, h = 28;
    const aug = document.createElement('canvas');
    aug.width = w;
    aug.height = h;
    const ctx = aug.getContext('2d');

    // 흰 배경
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);

    // --- 파라미터 설정 ---
    const angleDeg = preset && typeof preset.angleDeg === 'number'
      ? preset.angleDeg
      : (Math.random() - 0.5) * 40;   // -20° ~ +20°
    const angle = angleDeg * (Math.PI / 180);

    const scale = preset && typeof preset.scale === 'number'
      ? preset.scale
      : 0.9 + Math.random() * 0.2;    // 0.9 ~ 1.1

    const dx = preset && typeof preset.dx === 'number'
      ? preset.dx
      : (Math.random() - 0.5) * 6;    // -3 ~ 3px

    const dy = preset && typeof preset.dy === 'number'
      ? preset.dy
      : (Math.random() - 0.5) * 6;    // -3 ~ 3px

    const useNoise = preset && typeof preset.useNoise === 'boolean'
      ? preset.useNoise
      : Math.random() < 0.7;          // 기본: 70% 확률로 노이즈

    // --- 기하 변환 ---
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.rotate(angle);
    ctx.scale(scale, scale);
    ctx.translate(dx, dy);
    ctx.drawImage(baseCanvas, -w / 2, -h / 2, w, h);
    ctx.restore();

    // --- 노이즈 ---
    if (useNoise) {
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 30;
        data[i]   = Math.max(0, Math.min(255, data[i]   + noise)); // R
        data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise)); // G
        data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise)); // B
      }
      ctx.putImageData(imgData, 0, 0);
    }

    return {
      canvas: aug,
      info: {
        rotate: angleDeg.toFixed(1) + "°",
        shift: `(${dx.toFixed(1)}, ${dy.toFixed(1)})`,
        scale: scale.toFixed(2),
        noise: useNoise ? "ON" : "OFF"
      }
    };
  }

  // 데이터셋용 랜덤 증강 (기존 동작)
  function augment28x28(baseCanvas) {
    return applyAugmentation(baseCanvas, null);
  }

  createApp({
    setup() {
      const currentDigit = ref(0);
      const originalsCount = ref(0);
      const originalSamples = ref([]);   // dataURL 배열

      // { geo: [{url, info}], noise: [{url, info}] }
      const augmentedSamples = ref({
        geo: [],
        noise: []
      });
      const hasAugmentedSamples = computed(
        () =>
          augmentedSamples.value.geo.length > 0 ||
          augmentedSamples.value.noise.length > 0
      );

      const isWorking = ref(false);

      let canvas, ctx;
      let drawing = false;
      let lastX = 0, lastY = 0;

      function setDigit(d) {
        currentDigit.value = d;
        originalsCount.value = digitStore[d].originals.length;
        originalSamples.value = digitStore[d].originals
          .slice(0, 10)
          .map(c => c.toDataURL("image/jpeg", 0.9));
        augmentedSamples.value = { geo: [], noise: [] };
      }

      function initCanvas() {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
      }

      function drawGrid() {
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        // 세로선 (칸 너비 30)
        for (let x = 30; x < 300; x += 30) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, 150);
          ctx.stroke();
        }
        // 가로선 (칸 높이 30)
        for (let y = 30; y < 150; y += 30) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(300, y);
          ctx.stroke();
        }
      }

      function getCanvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        return { x, y };
      }

      function pointerDown(e) {
        e.preventDefault();
        drawing = true;
        const { x, y } = getCanvasPos(e);
        lastX = x;
        lastY = y;
      }

      function pointerMove(e) {
        if (!drawing) return;
        e.preventDefault();
        const { x, y } = getCanvasPos(e);
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastX = x;
        lastY = y;
      }

      function pointerUp(e) {
        e && e.preventDefault();
        drawing = false;
      }

      function attachEvents() {
        canvas.addEventListener("pointerdown", pointerDown);
        canvas.addEventListener("pointermove", pointerMove);
        window.addEventListener("pointerup", pointerUp);
      }

      function clearCanvas() {
        initCanvas();
      }

      // 현재 캔버스(300x150)를 10x5 → 28x28로 잘라서 저장
      // 이때 28x28 가장자리 1픽셀 테두리는 흰색으로 덮어서 그리드 선 제거
      function sliceTo28x28() {
        const temp = document.createElement("canvas");
        temp.width = 28;
        temp.height = 28;
        const tctx = temp.getContext("2d");

        const store = digitStore[currentDigit.value];
        store.originals = [];
        originalSamples.value = [];
        augmentedSamples.value = { geo: [], noise: [] };

        const totalCells = 50; // 10 x 5
        for (let i = 0; i < totalCells; i++) {
          const col = i % 10;
          const row = Math.floor(i / 10);
          const sx = col * 30;
          const sy = row * 30;

          // 28x28로 리샘플링
          tctx.fillStyle = "#ffffff";
          tctx.fillRect(0, 0, 28, 28);
          tctx.drawImage(canvas, sx, sy, 30, 30, 0, 0, 28, 28);

          // --- 가장자리 1픽셀 테두리 흰색으로 덮어서 선 제거 ---
          tctx.fillStyle = "#ffffff";
          // 위/아래
          tctx.fillRect(0, 0, 28, 1);
          tctx.fillRect(0, 27, 28, 1);
          // 왼쪽/오른쪽
          tctx.fillRect(0, 0, 1, 28);
          tctx.fillRect(27, 0, 1, 28);

          // 복제 캔버스에 저장
          const clone = document.createElement("canvas");
          clone.width = 28;
          clone.height = 28;
          clone.getContext("2d").drawImage(temp, 0, 0);
          store.originals.push(clone);

          if (i < 10) {
            originalSamples.value.push(
              clone.toDataURL("image/jpeg", 0.9)
            );
          }
        }

        originalsCount.value = store.originals.length;
        alert(`숫자 ${currentDigit.value}의 28×28 원본 ${store.originals.length}장을 메모리에 저장했습니다.`);
      }

      // 현재 숫자 데이터 초기화
      function resetDigitData() {
        if (!confirm(`숫자 ${currentDigit.value}의 저장된 이미지를 모두 지울까요?`)) return;
        digitStore[currentDigit.value].originals = [];
        originalsCount.value = 0;
        originalSamples.value = [];
        augmentedSamples.value = { geo: [], noise: [] };
      }

      // ZIP 생성 및 다운로드 (데이터셋용)
      // + 기하 변환 5개, 노이즈 5개 샘플 표시
      async function generateAndDownload() {
        const digit = currentDigit.value;
        const store = digitStore[digit];
        const originals = store.originals;

        if (!originals || originals.length < 1) {
          alert("먼저 50칸을 채우고 '50칸 → 28×28 원본 50장 저장'을 눌러주세요.");
          return;
        }

        isWorking.value = true;
        augmentedSamples.value = { geo: [], noise: [] };

        const TOTAL = 1000; // 최종 개수
        const needAug = Math.max(0, TOTAL - originals.length);

        const zip = new JSZip();
        const folder = zip.folder(`digit_${digit}`);

        // 1) 원본 저장 (img_digit_001 ~ img_digit_050)
        originals.forEach((c, idx) => {
          const fileIndex = idx + 1;
          const filename = `img_${digit}_${String(fileIndex).padStart(3, "0")}.jpg`;
          const dataUrl = c.toDataURL("image/jpeg", 0.9);
          const base64 = dataUrl.split(",")[1];
          folder.file(filename, base64, { base64: true });
        });

        const geoSamples = [];
        const noiseSamples = [];

        // 2) 증강 이미지 생성
        for (let i = 0; i < needAug; i++) {
          const base = originals[Math.floor(Math.random() * originals.length)];

          let preset = null;
          let sampleCategory = null;

          // 앞쪽 10개는 샘플용으로 만든다: 기하 5개, 노이즈 5개
          if (geoSamples.length < 5) {
            // 기하 변환 (회전/이동/크기)만, 노이즈 OFF
            preset = {
              angleDeg: (Math.random() - 0.5) * 40,
              dx: (Math.random() - 0.5) * 6,
              dy: (Math.random() - 0.5) * 6,
              scale: 0.9 + Math.random() * 0.2,
              useNoise: false
            };
            sampleCategory = "geo";
          } else if (noiseSamples.length < 5) {
            // 노이즈 중심: 위치/크기 고정, 노이즈 ON
            preset = {
              angleDeg: 0,
              dx: 0,
              dy: 0,
              scale: 1.0,
              useNoise: true
            };
            sampleCategory = "noise";
          } else {
            // 나머지는 완전 랜덤 증강
            preset = null;
            sampleCategory = null;
          }

          const { canvas: augCanvas, info } = applyAugmentation(base, preset);
          const fileIndex = originals.length + i + 1;
          const filename = `img_${digit}_${String(fileIndex).padStart(3, "0")}.jpg`;
          const dataUrl = augCanvas.toDataURL("image/jpeg", 0.9);
          const base64 = dataUrl.split(",")[1];
          folder.file(filename, base64, { base64: true });

          if (sampleCategory === "geo" && geoSamples.length < 5) {
            geoSamples.push({ url: dataUrl, info });
          } else if (sampleCategory === "noise" && noiseSamples.length < 5) {
            noiseSamples.push({ url: dataUrl, info });
          }
        }

        augmentedSamples.value = {
          geo: geoSamples,
          noise: noiseSamples
        };

        const blob = await zip.generateAsync({ type: "blob" });
        saveAs(blob, `digit_${digit}_1000_images.zip`);
        isWorking.value = false;
        alert(`숫자 ${digit}에 대해 원본 + 증강 합계 1000장을 ZIP으로 저장했습니다.`);
      }

      onMounted(() => {
        canvas = document.getElementById("drawCanvas");
        ctx = canvas.getContext("2d");
        initCanvas();
        attachEvents();
      });

      return {
        currentDigit,
        originalsCount,
        originalSamples,
        augmentedSamples,
        hasAugmentedSamples,
        isWorking,
        setDigit,
        clearCanvas,
        sliceTo28x28,
        generateAndDownload,
        resetDigitData
      };
    }
  }).mount("#app");
</script>
</body>
</html>
